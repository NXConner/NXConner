"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const fs = require("fs-promise");
const glob = require("glob");
const yaml = require("js-yaml");
const path = require("path");
const changeset_parser_1 = require("./changeset-parser");
const alpha_numeric_sorter_1 = require("./util/alpha-numeric-sorter");
function getChangesets(config, basePath) {
    const files = config.files
        .map((fileExpression) => glob.sync(path.join(basePath, fileExpression)).sort(alpha_numeric_sorter_1.default))
        .reduce((arr, globFiles) => {
        globFiles.forEach((file) => {
            const items = arr.slice();
            if (items.indexOf(file) === -1) {
                arr.push(file);
            }
        });
        return arr;
    }, []);
    const changesets = files
        .map((file) => changeset_parser_1.default.parseFile(file, basePath))
        .reduce((arr, cs) => arr.concat(cs), []);
    return changesets;
}
function listContainsAny(list1, list2) {
    for (const item of list1) {
        if (list2.indexOf(item) !== -1) {
            return true;
        }
    }
    return false;
}
class Migration {
    constructor() {
        this.changesets = [];
    }
    execute(repository, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const hasLock = yield repository.aquireLock();
            if (!hasLock) {
                throw new Error('Could not aquire database lock');
            }
            try {
                const changesets = yield this.filterChangesets(repository, options);
                for (const changeset of changesets) {
                    yield repository.executeChangeset(changeset);
                }
                return changesets;
            }
            finally {
                yield repository.releaseLock();
            }
        });
    }
    generateScript(repository, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const changesets = yield this.filterChangesets(repository, options);
            return changesets.map((c) => `-- ${c.formatName()}\n${c.script}`).join('\n\n');
        });
    }
    static load(filename) {
        return __awaiter(this, void 0, void 0, function* () {
            const migration = new Migration();
            const stat = yield fs.stat(filename);
            let basePath = null;
            const config = {
                files: ['**/*.sql'],
                sort: 'alpha-numeric',
            };
            if (stat.isFile()) {
                const contents = yield fs.readFile(filename, 'utf8');
                if (/\.ya?ml$/.test(filename)) {
                    Object.assign(config, yaml.safeLoad(contents));
                }
                else {
                    Object.assign(config, JSON.parse(contents));
                }
                basePath = path.dirname(filename);
            }
            else {
                basePath = filename;
            }
            migration.changesets = getChangesets(config, basePath);
            return migration;
        });
    }
    filterChangesets(repository, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const validation = yield Promise.all(this.changesets.map((changeset) => __awaiter(this, void 0, void 0, function* () {
                return ({
                    changeset,
                    validation: yield repository.validateChangeset(changeset),
                });
            })));
            const { context = null } = options || {};
            const messages = validation
                .filter((v) => v.validation.messages.length)
                .map((v) => `${v.changeset.formatName()}\n${v.validation.messages.map((m) => `  ${m}`).join('\n')}`);
            const statements = [];
            if (messages.length) {
                throw new Error(messages.join('\n'));
            }
            return validation.filter((v) => v.validation.shouldExecute)
                .filter((v) => !context
                || !v.changeset.context
                || listContainsAny(v.changeset.context.split(/\s*,\s*/), context))
                .map((v) => v.changeset);
        });
    }
}
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = Migration;
//# sourceMappingURL=migration.js.map