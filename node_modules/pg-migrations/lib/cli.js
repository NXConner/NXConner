#!/usr/bin/env node
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const program = require("commander");
const ConnectionString = require("pg-connection-string");
const read = require("read");
const changelog_repository_1 = require("./data/changelog-repository");
const migration_1 = require("./migration");
const info = require('../package.json');
function list(str) {
    if (typeof str === 'string') {
        return str.split(/\s*,\s*/g);
    }
    return [];
}
program
    .version(info.version)
    .description('Database migration tool for postgres databases')
    .arguments('<schema>')
    .usage('<schema file|directory> [options]')
    .option('-c, --connection <connection string>', 'database connection string (required)', ConnectionString.parse)
    .option('-u, --user <user>', 'database user name')
    .option('-p, --password <password>', 'database password')
    .option('-P, --prompt-password', 'prompt for database password')
    .option('-s, --generate-script', 'output sql script instead of executing the migration')
    .option('--context [contexts]', 'changeset contexts to execute');
program.parse(process.argv);
const processCommand = function processCommand(schema, ...args) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!schema) {
            console.error('Error: schema file or directory is required');
            this.help();
            process.exit(1);
        }
        if (!this.connection) {
            console.error('Error: connection string is required');
            this.help();
            process.exit(1);
        }
        if (this.user) {
            this.connection.user = this.user;
        }
        if (this.password) {
            this.connection.password = this.password;
        }
        if (this.context) {
            this.context = list(this.context);
        }
        if (this.promptPassword) {
            const prompt = new Promise((resolve, reject) => {
                read({ prompt: 'Password: ', silent: true }, (err, password) => {
                    if (err) {
                        reject(err);
                    }
                    resolve(password);
                });
            });
            this.connection.password = yield prompt;
        }
        const repo = new changelog_repository_1.default(this.connection);
        const migration = yield migration_1.default.load(schema);
        if (this.generateScript) {
            console.log(yield migration.generateScript(repo, { context: this.context }));
        }
        else {
            const changes = yield migration.execute(repo, { context: this.context });
            console.log(`${changes.length} ${changes.length === 1 ? 'change' : 'changes'} applied`);
        }
    });
}.bind(program);
processCommand(...program.args).then(() => {
    process.exit();
}, (err) => {
    console.error(err);
    process.exit(1);
});
//# sourceMappingURL=cli.js.map